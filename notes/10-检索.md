# 10 检索
## 定义
- 平均检索长度 (ASL)
$$ASL=\sum_{i=1}^n P_iC_i$$
> 注意概率分布的隐含条件 $\sum p = 1$

## 线性表检索
**"监视哨"顺序检索算法**
- 即为在待检索的数组末尾加上 $a[n]=key$, 以节省遍历时的数组越界检查, 复杂度还是 $O(n)$
- 性能分析: (假设检索成功率是 $p$)
$$\frac{n+1}{2}<ASL=\frac{n+1}{2}p+(n+1)(1-p)<n+1$$
- 优点 : 插入元素可以直接加在末尾
- 缺点 : 检索时间太长 $\Theta(n)$

**二分检索法**
- 就是二分法, 需要先对数据排序
- 成功的平均检索长度
$$ASL_{succ} = \frac{1}{n}\sum_{i=1}^ji\cdot 2^{i-1} = \frac{n+1}{n}\log_2(n+1)-1\approx \log_2(n+1)-1$$
- 最大检索长度 $\lceil\log_1(n+1)\rceil$, 失败检索长度 $\lceil\log_2(n+1)\rceil$ 或 $\lfloor\log_2(n+1)\rfloor$
- 优点: 平均与最大检索长度相近, 检索速度快
- 缺点: 要排序, 顺序存储, 不易更新(插/删)

**分块检索**
- 按块有序, 块内无序, 是顺序与二分法的折衷
- $n$ 个元素, $b$ 个块 , 每个块至多 $s$ 个元素



$$\begin{align*}ASL&=ASL_b+ASL_w\\&\approx\log_2 (b+1)-1+\frac{s+1}{2}\end{align*}$$

- 当大量插入/删除时, 或结点分布不均匀时, 速度下降

## 集合检索
- 对于密集型集合, 用位向量表示, $\{0,1\}$ 表示是否有这个元素
  - 用 ulong 存, 每个存32个位
  - 位运算模拟集合交并

## 散列表检索

- **负载因子** $\alpha = $ 填入表中的结点 $n/$ 散列表空间大小 $m$
- **冲突** : 不同关键码计算出了相同的散列地址
  - 现实中不冲突的散列函数极少存在
  - **同义词** : 产生冲突的两个关键码

### 散列函数选取
$$Address = Hash(Key)$$
- 运算简单, 值域在表长范围内, 尽可能单射

**常用散列函数**
- **除余法** : $hash(key) = key/M$, 其中 $M$ 是一个接近散列长度的质数
  - 缺点 : 连续的关键码映射成连续的散列值, 占据连续数组单元, 可能导致性能降低
- **乘余取整法** : $hash(key) = \lfloor n\{Akey\}\rfloor$, 其中 $A\in (0,1)$
  - 若地址空间为 $p$, 就取 $n=2^p$, 则地址恰是小数点后 $p$ 位
  - $A$ 可以取任何值, 与待排序的数据特征有关, 一般取黄金分割最理想
- **平方取中法** : 先求平方, 再取其中几位或其组合作为地址
- **数字分析法** : 对 $n$ 个 $d$ 位数, 每一位可能有 $r$ 种不同的符号, 在各位上出现频率不一定相同. 可根据散列表大小, 选取期中分布均匀的若干位作为地址.
  - 这一方法完全依赖于关键码集合的性质
> 各位数字中符号分布的均匀度 $\lambda_k$
> $$\lambda_k = \sum_{i=1}^r(\alpha_i^k - n/r)^2$$
> - $\alpha_i^k$ : 第 $i$ 个符号在第 $k$ 位上出现的次数
> - $n/r$ : 各种符号在 $n$ 个数中均匀出现的期望值
> - $\lambda_k$ 越小, 说明越均匀
- **基数转换法** : 把关键码看成是另一进制上的数, 再把它转换成原来进制上的数, 取其中若干位作为散列地址
  - 一般取大于原来基数的数, 且互素
- **折叠法** : 将关键码分割成几部分, 将其叠加 (舍去进位) 作为散列地址
  - 移位叠加 : 把各部分的最后一位对齐相加
  - 分界叠加 : 各部分不折断, 来回折叠对齐相加
  - 适用于长关键码
- **ELFhash字符串散列函数** : 
  - 长字符串和短字符串都很有效
  - 字符串中每个字符都有同样的作用
  - 对于散列表中的位置不可能产生不平均的分布
```
int ELFhash(char* key) {
  unsigned long h = 0;
  while(*key) {
    h = (h << 4) + *key++;
    unsigned long g = h & 0xF0000000L;
    if (g) h ^= g >> 24;
    h &= ~g;
  }
  return h % M;
}
```

### 解决冲突
#### 开散列方法
即链表存指针, 
- 平均每个链表有 $n/M$ 个记录
- $M>n$ 时, 平均代价是 $\Theta(1)$
#### 闭散列方法
??? 没看懂

**常见闭散列方法**
- **线性探查** : 
- **二次探查** : 