# 6 树
## 6.1 基本概念
和数学中的定义(无圈图)不太一样, 数算里的树是除了根之外所有点入度均为1的有向树, **被摆放的很整齐**.
> 同属于形式语言的数学语言和计算机语言, 前者只刻画性质, 而后者只保证可计算性. 我觉得树就是最好的例子. 根对于数学毫无意义, 但它在计算机语言中则是递归的起点
> 本质是因为数学语言的主体是推理者, 计算机语言的主体是电路
- **根** : 唯一没有入度的节点
- **子树**, **前驱**
- **有向有序树** :  有序是指子树间有次序
  - 度为2的有序树 $\neq$ 二叉树 : 前者的单边节点的子树不分左右,都是第一子树
- **度数** : 指出度, 即子树个数
- **森林** : 0或多棵不相交的树的集合
### 树形结构的表示法
- 树形表示法
画树状图
- 形式语言表示法
定义节点集合和关系集合
- 文氏图表示法
用Venn 图的包含表示树的有向边
- 凹入表表示法
类似图书目录
- 嵌套括号表示法
迭代 Node()()


### 森林与二叉树的一一映射
- 树或森林与二叉树存在一一对应的映射.
- **森林$\rightarrow$二叉树**
  - 数学语言:
    - **加线**：在树中所有相邻的兄弟之间加一连线(从左指向右). 
    - **抹线**：对树中每个结点, 除最左孩子外, 抹去该结点与孩子间的连线. 
    - **整理**
  - 伪代码:
  ```
  ForestToBinaryTree(F): \\F = [T_1,T_2,...T_n]
    空二叉树根节点 T
    F_1 = [T_11,T_12,...T_1m] \\ T_1除去根节点后的森林
    F_2 = [T_2,...T_n] \\ F除去T_1后的森林
    T->leftchild = ForestToBinaryTree(F_1)
    T->rightchild = ForestToBinaryTree(F_2)
    返回 T
  ```
- **二叉树$\rightarrow$森林**
  - 以上变换的逆, 容易书写不做赘述
### 森林的遍历
- 先根dfs = 前序遍历二叉树
- 后根dfs = 中序遍历二叉树
- bfs : 同深度层被定义为二叉树储存结构的右斜线, 不能用二叉树的广度遍历模版
## 6.2 树的存储
### 子结点表示法
- 优点：查孩子个数和结点的值容易. 
- 缺点：找兄弟结点困难. 
- 树的归并容易：只需将一课树的根添加到另一棵树的孩子结点表中即可. 
### 2.动态结点表示法：指针数组法
### 3.静态“左孩子/右兄弟”表示法
![image.png](https://zhangzinuo-pictures.oss-cn-beijing.aliyuncs.com/img/202310200938020.png)
优点：
- 空间效率比子结点表示法更高. 
- 每个结点仅需**固定大小的存储空间**. 
### 4.动态“左孩子/右兄弟”表示法
本质上, 使用二叉树来替换树. 
- 左子结点在树中是结点的最左子结点. 
- 右子结点是结点原来的右侧兄弟结点. 
- 每个结点均包含固定数目的指针. 
判定寻找`父结点`：
![image.png](https://zhangzinuo-pictures.oss-cn-beijing.aliyuncs.com/img/202310200948906.png)
![](https://zhangzinuo-pictures.oss-cn-beijing.aliyuncs.com/img/202310270815363.png)

### 5.父指针表示法及在并查集中的应用
- 每个结点仅保存指向其父结点的指针域即可, 成为**父指针表示法**. 
- 用数组存储树中所有结点, 每个结点附设一个“指针”指示其父结点. 
- 优点：
	- 寻找父结点只需要O(1)时间. 
	- 求树根结点非常方便. 
- 缺点：
	- 寻兄弟结点麻烦,  需要查询整个树结构. 
	- 没有标识节点的左右次序, 适合**无序树**的情况. 
#### 并查集
特殊集合, 由不相交子集构成. 
基本操作：
- Find:找到其对应的根节点. 
- Union：归并两个集合. 
- Different：判定是否在同一集合/树中. 
##### 重量权衡合并规则
- 将结点较少树的根结点指向结点较多树的根结点. 
- 这可以把树的整体深度限制在O(logn). 
- 当处理完n个等价对后, 任何结点的深度最多只会增加logn次. 
##### 路径压缩算法
## 6.3 树的顺序存储
### 6.3.1 带右链的先根次序表示法
- 任何结点的子树的所有结点都直接跟在该结点之后. 
- 每棵子树的所有结点都聚集在一起, 中间不会插入别的结点. 
- 任何一个分支结点后面跟的都是它的第一个子结点（**如果存在的话**）. 
- 结点除包含本身数据外, 还附加两个表示结构的信息字段ltag（0有子结点, 1无子结点）, info, rlink（右指针, 指向下一个兄弟）. ltag可以重塑llink, 但是占用存储空间更少. 
### 6.3.2 带双标记位的先根次序表示法
- 用rtag代替rlink. 
- rtag为1, 结点无兄弟；rtag为0, 有右兄弟. 
- 当结点x的rtag为0时, 它的rlink应指向结点序列中排在以结点x为根的子树中最后结点的后面的那个结点y. 
- **有兄弟结点和无孩子结点一一对应, 满足栈特性. **
结点x的兄弟结点y的确定方法：
![image.png](https://zhangzinuo-pictures.oss-cn-beijing.aliyuncs.com/img/202310270932278.png)
**有兄弟就入栈, 无孩子就出栈**. 
### 6.3.3 带度数的后根次序表示法
- info是结点的数据, degree是结点的度数. 
- 将带度数的后根次序转化成森林时
	- 从左至右进行扫描, 度为0的结点是叶子结点（也可看做一棵子树）. 
	- 当遇到度数非0（设为k）的结点时, 则排在该结点之前且离它最近的k个子树的根就是该结点的k个子结点. 
- 利用栈实现：
	- 遇到零度顶点就入栈. 
	- 遇到非零k度顶点就从栈中弹出k个节点作为其子结点, 然后将该非零顶点入栈. 
	- 持续扫描, 直至序列扫描完毕. 
- 思考：
	- 带度数的先根次序？ 从右到左即可. 
	- 带度数的层次次序？
### 6.3.4 带双标记的层次次序表示
- 先看rtag：
	- rtag=0：下一个结点即为其兄弟结点. 
	- rtag=1：无兄弟结点. 
- 再看ltag：
	- ltag=1：无孩子结点. 
	- ltag=0：有孩子结点. <—**重点考虑**
- **有孩子节点与无兄弟节点一一对应, 满足队列特性. **
- **有孩子则入队列, 无兄弟则出队列**. 
## 6.4 K叉树
K叉树的结点有K个**有序子结点**. 
# 期中考试整理
## 求最大矩形面积
> 给定 n 个非负整数, 代表柱状图上每个柱的高度（每个柱的宽度均为 1）, 求这个柱状图中最大的矩形面积. 

## O(n^3)
枚举所有左右边界可能性, 并且在边界内找最低的柱子, 枚举边界复杂度O(n^2), 找最低柱子O(n), 总复杂度O(n^3)
## O(n^2)
- 枚举每个柱子作为右边界, 往回枚举所有之前的柱子作为左边界, 枚举过程中记录最低柱子, 则最矮柱子\*左右边界距离为当前矩阵面积. 
- 取所有这样的面积最大值, 右边界有O(n)种可能, 往回找比它矮的柱子也是O(n), 总复杂度为O(n^2)
## O(n)
- 关键：维护一个栈, 用于存储直方图柱子中的索引, 并保证栈中索引对应的柱子高度递增(**单调栈**)
	- 枚举直方图中的每一个柱子
	- 当栈为空, 或者当前柱子的高度大于栈顶柱子的高度时, 将当前柱子的索引压入栈. 
	- 当当前柱子的高度小于或等于栈顶索引对应柱子的高度时, 持续从栈中弹出柱子, 直到栈为空或者栈顶柱子的高度小于当前柱子的高度. 弹出操作结束后, 压入当前柱子的索引. 
	- 对于每一个弹出的柱子, 计算以该柱子为高度向两边扩展能得到的最大宽度：
		- 若栈非空, 最大宽度为当前柱子到弹出柱子的距离(不含当前柱子)
		- 若栈为空, 最大宽度为到当前柱子为止的总柱子数减1, 根据高度与最大宽度来求当前矩形面积, 并更新最大面积. 