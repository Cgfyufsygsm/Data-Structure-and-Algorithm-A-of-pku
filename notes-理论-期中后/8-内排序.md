---
id: notes
---
@import "/.crossnote/notes.less";

# 8 内排序
- 内排序 : 整个排序过程在内存中完成
- 稳定性 : 存在多个具有相同排序码的记录, 排序后这些记录的相对次序保持不变

## 算法一览

<img src="../image/内排序算法.png">

- 索引排序
- 对时间复杂度的理解
  - 序列平均有 $\frac{1}{2}\binom{n}{2}$ 对逆序
    - 任何一种只对相邻记录进行比较的排序算法的平均时间代价都是 $\Theta(n^2)$
  - $n$ 很小或基本有序时插入排序比较有效 
  - Shell 排序选择增量以3的倍数递减
    - 需要保证最后一趟增量为1
  - 综合性能快速排序最佳
  - 排序问题的时间复杂度下限, 也即判定树的最小深度: $\Omega(\log n!)=\Omega (n\log n)$


<div class="question-box">
    <span class="title">(2016 秋)</span>
    <p>在快速排序中, 定义一次平分的划分为 "幸运的划分", 而一次划分如果有一边为空则是"不幸的划分". 假设划分的过程总是"幸运"和"不幸"交替的, 则该快速排序的时间复杂性为 ____?</p> <br/>
</div>
    
**解析:** 不幸的效果不计, 幸运的划分时间复杂度为 $O(n)$, 一共有 $2\log n$ 次划分. 相当于复杂度的常数损失了一半.
**答案:** 还是 $O(n\log n)$
___