---
id: notes
---
@import "/.crossnote/notes.less";

# 10 检索
## 10.1 定义
- 平均检索长度 (ASL)
$$ASL=\sum_{i=1}^n P_iC_i$$
> 注意概率分布的隐含条件 $\sum p = 1$

### 线性表检索
**"监视哨"顺序检索算法**
- 即为在待检索的数组末尾加上 $a[n]=key$, 以节省遍历时的数组越界检查, 复杂度还是 $O(n)$
- 性能分析: (假设检索成功率是 $p$)
$$\frac{n+1}{2}<ASL=\frac{n+1}{2}p+(n+1)(1-p)<n+1$$
- 优点 : 插入元素可以直接加在末尾
- 缺点 : 检索时间太长 $\Theta(n)$

**二分检索法**
- 就是二分法, 需要先对数据排序
- 成功的平均检索长度
$$ASL_{succ} = \frac{1}{n}\sum_{i=1}^ji\cdot 2^{i-1} = \frac{n+1}{n}\log_2(n+1)-1\approx \log_2(n+1)-1$$
- 最大检索长度 $\lceil\log_1(n+1)\rceil$, 失败检索长度 $\lceil\log_2(n+1)\rceil$ 或 $\lfloor\log_2(n+1)\rfloor$
- 优点: 平均与最大检索长度相近, 检索速度快
- 缺点: 要排序, 顺序存储, 不易更新(插/删)

**分块检索**
- 按块有序, 块内无序, 是顺序与二分法的折衷
- $n$ 个元素, $b$ 个块 , 每个块至多 $s$ 个元素



$$\begin{align*}ASL&=ASL_b+ASL_w\\&\approx\log_2 (b+1)-1+\frac{s+1}{2}\end{align*}$$

- 当大量插入/删除时, 或结点分布不均匀时, 速度下降

### 集合检索
- 对于密集型集合, 用位向量表示, $\{0,1\}$ 表示是否有这个元素
  - 用 ulong 存, 每个存32个位
  - 位运算模拟集合交并

### 散列表

- **负载因子** $\alpha = $ 填入表中的结点 $n/$ 散列表空间大小 $m$
- **冲突** : 不同关键码计算出了相同的散列地址
  - 现实中不冲突的散列函数极少存在
  - **同义词** : 产生冲突的两个关键码

## 10.2 散列函数选取
$$Address = Hash(Key)$$
- 运算简单, 值域在表长范围内, 尽可能单射

**常用散列函数**
- **除余法** : $hash(key) = key/M$, 其中 $M$ 是一个接近散列长度的质数
  - 缺点 : 连续的关键码映射成连续的散列值, 占据连续数组单元, 可能导致性能降低
- **乘余取整法** : $hash(key) = \lfloor n\{Akey\}\rfloor$, 其中 $A\in (0,1)$
  - 若地址空间为 $p$, 就取 $n=2^p$, 则地址恰是小数点后 $p$ 位
  - $A$ 可以取任何值, 与待排序的数据特征有关, 一般取黄金分割最理想
- **平方取中法** : 先求平方, 再取其中几位或其组合作为地址
- **数字分析法** : 对 $n$ 个 $d$ 位数, 每一位可能有 $r$ 种不同的符号, 在各位上出现频率不一定相同. 可根据散列表大小, 选取期中分布均匀的若干位作为地址.
  - 这一方法完全依赖于关键码集合的性质
> 各位数字中符号分布的均匀度 $\lambda_k$
> $$\lambda_k = \sum_{i=1}^r(\alpha_i^k - n/r)^2$$
> - $\alpha_i^k$ : 第 $i$ 个符号在第 $k$ 位上出现的次数
> - $n/r$ : 各种符号在 $n$ 个数中均匀出现的期望值
> - $\lambda_k$ 越小, 说明越均匀
- **基数转换法** : 把关键码看成是另一进制上的数, 再把它转换成原来进制上的数, 取其中若干位作为散列地址
  - 一般取大于原来基数的数, 且互素
- **折叠法** : 将关键码分割成几部分, 将其叠加 (舍去进位) 作为散列地址
  - 移位叠加 : 把各部分的最后一位对齐相加
  - 分界叠加 : 各部分不折断, 来回折叠对齐相加
  - 适用于长关键码
- **ELFhash字符串散列函数** : 
  - 长字符串和短字符串都很有效
  - 字符串中每个字符都有同样的作用
  - 对于散列表中的位置不可能产生不平均的分布
```
int ELFhash(char* key) {
  unsigned long h = 0;
  while(*key) {
    h = (h << 4) + *key++;
    unsigned long g = h & 0xF0000000L;
    if (g) h ^= g >> 24;
    h &= ~g;
  }
  return h % M;
}
```

## 10.3  解决冲突
### 开散列方法

**拉链法** : 适用于内存
- 把散列表中的每个槽定义为一个链表的表头, 散列到特定槽的所有记录都放到这个槽的链表中
  - 同义词表可以根据输入, 访问频率, 值的顺序组织
- 优点 : 简单, 适用于大量数据, 可取 $\alpha\ge 1$, 结点较大时效果好
- 缺点 : 在磁盘上会产生大量访问开销

**桶式散列** : 适用于磁盘
> 没啥意思, 感觉不会考

### 闭散列方法

- $d_0=h(K)$ 称为**基地址**, 当冲突发生时, 使用某种方法为关键码 $K$ 产生一个新的散列地址序列, 称为**探查序列**
  - $d_i = d_0 + p(K,i) $, $i\in [M-1]$, 其中 $p$ 是探查函数

- 检索要遵循插入时同样的探查序列
  - 重复冲突解决过程
  - 找出在基位置没有找到的记录
- 插入和检索函数都假定每个关键码的探查序列中欧至少有一个存储位置是空的
  - 也可以限制探查序列长度

**线性探查**
- $p(K,i) = i$
- 产生的问题 : "聚集", 小聚集汇合成大聚集, 导致很长的探查序列
- 改进 : $p(K,i) = i*c$, 但还是会有探查序列纠缠

**二次探查**
- $p(K,2i-1) = i^2, p(K,2i) = -i^2$

<div class="question-box">
    <span class="title">(2021 秋)</span>
    <p>将关键字序列 <b>7、8、30、11、18、9、14</b> 散列存储到散列表中. 散列表是一个下标从 <b>0</b> 开始的一维数组, 散列函数为: <b>H(key) = (key * 5) MOD 7 </b>, 处理冲突采用二次探测法, 要求装填(载)因子为0.7.</br>
<b>(1)</b> 请画出所构造的散列表.<br/>
<b>(2)</b> 计算等概率情况下查找成功和查找失败的平均查找长度.</p> <br/>
</div>
    
**(1)** 数组长度 $L = 7/0.7 = 10$, 这里很有意思的一点, 就是不冲突的话只会在长为 $10$ 的数组的前 $7$ 个位置上储存, 这意味着 hash 选取的 M 未必是散列表大小.
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|---|---|---|---|---|---|---|---|---|---|
| 7 |  | 14 | 30 | 9 | 8 | 11 | 18 |  |  |

**(2)**  $ASL_{succ}$ : 将 $7, 8, 30, 11, 18, 9, 14$ 带入 key 去查找
$$ASL_{succ} = \frac{1}{7}(1+1+1+1+2+2+2) = \frac{10}{7}$$
$ASL_{fail}$ : 实际上是在 $|\mathbb{N}| \to +\infty$ 时是自然地等概率选择模 $7$ 剩余系, 可以选 $0, 1, 2, 3, 4, 5, 6$ 代入 key , 因为他们都一定失败.
$$ASL_{fail} = \frac{1}{7}(3+2+1+3+4+4+5) = \frac{22}{7}$$

___

**伪随机数序列探查**
- $p(K,i) = R(i-1)$, 其中 $R$ 是一个值从 $[M-1]$ 的伪随机数序列
- 二次探查和伪随机数探查都能避免基本聚集
- **二级聚集** : 两个关键码散列到同一个基地址, 还是得到同样的探查序列, 所产生的聚集
  - 避免方法 : 探查序列是原来关键码值的函数, 而不仅仅是基地址的函数

**双散列探查法**
- $p(K,i) = i\cdot h_2(K)$, 其中 $h_2(K)$ 是第二个散列函数
- $h_2(K)$ 必须于 $M$ 互素
  - 使发生冲突的同义词地址均匀de分布在整个表中
  - 否则可能造成同义词地址的循环计算
- 优点 : 无聚集, 无循环, 无二级聚集
- 缺点 : 散列函数计算量大

## 10.4 散列字典实现
用散列表实现的字典

**插入**
- 若表中基地址空间未被占用, 则插入记录
- 若基地址的值与关键码相等, 则报告重复 (不允许重复记录)
- 否则按设定的处理冲突方法去找下一个地址, 重复上述过程

**检索**
- 若基地址中的值为空, 则找不到
- 地址中的值与关键码相等, 则找到
- 否则按设定的处理冲突方法去找下一个地址, 重复上述过程

**删除**
两点需要考虑:
- 删除后, 该地址的记录是否会影响检索
- 释放存储位置能为将来所用
  - 只有开散列方法可以真正删除, 空间重用
  - 闭散列方法都只能作标记, 不能真正删除, 空间未再次分配之前不可用
- **墓碑** : 用一个特殊的值表示删除
  - 不能将空单元与删除单元混淆 : 检索时遇到已删除标记还需要继续检索下去
- 删除操作与检索类似, 但是删除后地址标记为删除
- 带墓碑的插入 : 可以插, 但是检索要继续, 防止插入两个相同的关键码