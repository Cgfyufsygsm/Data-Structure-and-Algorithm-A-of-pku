---
id: notes
---
@import "/.crossnote/notes.less";

# 12 高级数据结构
## 12.1 多维数组和稀疏矩阵

### 多维数组
行优先顺序: 先排最右下标, 从右到左, 最后排最左下标
列优先顺序: 先排最左下标, 从左向右, 最后排最右下标
对于行优先顺序:
$$loc(A[j_0,\dots,j_{n-1}])=loc(A[0,...,0])+d[\sum_{i=0}^{n-2}j_i\prod_{k=i+1}^{n-1}d_k+j_{n-1}]$$
### 特殊矩阵
**对称矩阵/三角矩阵** 
- 只存上三角或者下三角

**稀疏矩阵** 
- 三元组表示法 : 行数 $M$, 列数 $N$, 非零元素个数 $T$, $\{(i,j,a_{ij})|a_{ij}\neq 0\}$
- 十字链表 : 行链表头指针数组, 列链表头指针数组, $\{(i,j,a_{ij},*\text{nextcol},*\text{nextrow})\}$
- **CSR** (压缩稀疏矩阵表示) : 行指针数组, 列索引数组, 非零元素数组
  - 每一行对应列索引数组的一个区间, 该区间内的元素为矩阵该行非零元素的列索引, 行指针指向该区间的起始位置, 列索引与非零元素数组的下标对齐

## 12.2 广义表
对于**广义表** $L=(x_0,\dots,x_{n-1})$
  - $x_i$ 可以是单个元素 (即原子 atom), 也可以是广义表 (即子表 sublist)
  - 广义表深度 : 递归定义, 原子的深度为0, 非原子的深度为其元素的最大深度加1
  - 表头 $x_0$, 表尾 $x_{1:n-1}$

<div class="question-box">
  <span class="title">(2016 秋)</span>
    <p>已知广义表 <b>C=(c, (d, A), B, e)</b>，则: </p>
    <p>1. 广义表 <b>C</b> 的深度为 _______. </p>
    <p>2. <b>tail(head(tail(C)))</b> 的运算结果为 _______. </p>
</div>

**答案** : 2, (A)
**解析** : ```head()``` 返回元素或者作为元素的子表, 这取决于第一个元素是什么. 但 ```tail()``` 一定返回子表即便表中只有一个元素或者一个子表, 要打括号.

<div class="question-box">
    <span class="title">(2021 秋)</span>
    <p>假设广义表 <b>P=(L:(a, b, Lz), L₂:(L, b, c), L₃:(c, d, Lz))</b></p><br>
    <p><b>(1)</b> 画出图形表示:</p><br>
    <p><b>(2)</b> 该表的深度是多少?</p><br>
    <p><b>(3)</b> 使用头尾 (<b>Head()</b>, <b>Tail()</b>) 运算找出 <b>d</b> 元素.</p>
</div>

**解析** :
(1) 广义表的图形表示一个元素一个节点, 一个子表一个节点, 用指针连接
(2) 大胆填正无穷
(3) 第2个 ```head()``` 是为了取出 $L_3$
**答案** :  (1) 
<img src = "../image/12-1.png" width = 300> 
(2) $+\infty$
(3) ```head(tail(head(tail(tail(P)))))```
___

### 广义表的类型
- **纯表** (pure list) 
  - 从根节点到任何叶节点只有一条路径
  - 任何元素 (原子, 子表) 只能出现一次
- **可重入表(再入表)** (reentrant list)
  - 任何元素可以出现多次
  - 对应一个DAG
- **循环表(递归表)** (circular list)
  - 包含回路, 深度无穷大

$$图\supseteq再入表\supseteq纯表(树)\supseteq 线性表$$

> 应用: Lisp语言中的S表达式, 函数调用关系, 内存引用关系
### 广义表的ADT
```cpp
struct TreeNode {
    bool isAtom;       // true: 原子, false: 子表
    union {
        char atom;     // 原子值
        TreeNode* sublist; // 子表指针
    };
    TreeNode* sibling;  // 指向同层兄弟节点
};
```
> 为什么广义表要有头结点? 否则删除结点必须进行链调整, 增加头指针可以简化删除, 插入操作. 
>
> 头指针tag可以是-1, value为空. 只有指向第一个结点的指针

## 12.3 字符树
本节只做了解

以存储字符串集合 ["bear", "bell", "bid", "bull", "buy", "sell", "stock", "stop"] 为例
```
前缀trie
          (root)
         /  |   \
        b   s    ...
       /|    \
      e i     t
     /|  \     \
    a l   d      o
   /   \          \
  r     l          c
 /       \          \
(end)     l          k
          |           \
         (end)        (end)

patricia树
          (root)
         /      \
      "b"       "s"
      / \         \
   "ear" "ull"   "ell"
     |       \       \
  (end)      "y"    "tock"
              |        \
             (end)     "op"
                        (end)
```
## 12.4 最佳BST树
一个 $n$ 个关键码的集合, 关键码可以有 $n!$ 种不同的排列法, 但是对应的二叉搜索树只有 $C_{2n}^n/(n+1)$ 种不同的形态.

**效率度量**
- 先扩充二叉搜索树, 添加外部空节点, 为检索失败的情形提供一个关键码区间
- 成功检索 : 关键码层数加1 (根是第0层)
- 失败检索 : 被检索关键码所属的外部空节点层数
$$ASL=\frac{\sum_{i=1}^n p_i(l_i+1)+\sum_{i=0}^nq_il_i'}{\sum_{i=1}^n p_i+\sum_{i=0}^nq_i}$$
- $p_i$ : 成功检索第 $i$ 个内部节点的概率 (总共 $n$ 个)
- $q_i$ : 失败检索第 $i$ 个外部节点的概率 (总共 $n+1$ 个)
- $l_i$ : 第 $i$ 个内部节点的层数
- $l_i'$ : 第 $i$ 个外部节点的层数

**最佳BST** : 使得平均检索长度最小的二叉搜索树, 这取决于关键码的概率分布
- 关键码概率分布均匀时 ($p_i=q_i=\frac{1}{2n+1}$), 等价于最小化内部路径长度和, 最佳BST是一棵完全二叉树
- 关键码概率分布不均匀时, 其任何子树都是最佳BST
  - **动态规划** : 从底向上, 逐层计算最佳二叉搜索树的平均检索长度

## 12.5 AVL树

**AVL树的性质**
- 空树是AVL树
- 左右子树都是AVL树, 且左右子树的高度差的绝对值不超过1
- $n$ 个结点的AVL树的高度不超过 $O(\log n)$

> $bf(x)$ : 节点 $x$ 的平衡因子, 即右子树高度减去左子树高度, 取值范围 $\{-1,0,1\}$
>
> AVL 树的 $ASL$ 为 $O(\log n)$

**AVL树的插入**
- 与BST类似, 执行失败的查找, 确定插入位置插入新结点
- 若插入后不破坏平衡性, 则逐层调整平衡因子
- 若插入后破坏平衡性, 则进行旋转操作, 从新加入的结点 $u$ 向根方向往上搜索, 直到找到距离 $u$ 最近的不平衡祖先结点 $A$ (平衡因子为2或者-2) 定位路径 $A\to B\to C\to \dots \to u$.
  - **LL型** : $A\overset{left}{\to} B\overset{left}{\to} C$, 右旋一次, 让 $B$ 取代 $A$ 成为新的子树根即可
  - **RR型** : $A\overset{right}{\to} B\overset{right}{\to} C$, 左旋一次, 让 $B$ 取代 $A$ 成为新的子树根即可
  - **LR型** : $A\overset{left}{\to} B\overset{right}{\to} C$, 先对 $B$ 左旋, $C$ 取代 $B$, 再对 $A$ 右旋, $C$ 取代 $A$ 成为新的子树根
  - **RL型** : $A\overset{right}{\to} B\overset{left}{\to} C$, 先对 $B$ 右旋, $C$ 取代 $B$, 再对 $A$ 左旋, $C$ 取代 $A$ 成为新的子树根

**AVL树的删除**
- 与BST类似, 执行失败的查找, 确定删除位置, 与后继交换再删除
- 删除会导致树高及平衡因子变化, 需要沿着被删除结点到根结点的路径来调整这种变化. 但删除比插入复杂, 可能需要在相应的路径上的不止一次实施单旋或双旋

> AVL树的插入和删除操作的时间复杂度为 $O(\log n)$

**AVL树的扩展**
允许树的高度差 $\Delta$ 超过1, 但是仍然保持平衡性, 最差情况下高度随 $\Delta$ 增长, 与单纯的AVL树 ($\Delta = 1$) 相比, 平均访问节点数目增加了, 但重组的数目降低了

## 12.6 伸展树

**展开(splaying)** : 访问一次节点 $x$, 完成一次展开过程
- 插入检索 $x$ 时, 把 $x$ 旋转到根节点
- 删除检索 $x$ 时, 把 $x$ 的父节点旋转到根节点
- 当 $x$ 是根节点的子节点时, 用单旋转 (和AVL树的旋转相同)
- 否则递归地进行双旋转
  - **一字型旋转**, 也称为同构调整, 适用于 $x$ 是祖父节点的左左孙子节点或右右孙子节点, 相当于两次单旋转
  - **之字型旋转**, 也称为异构调整, 适用于 $x$ 是祖父节点的左右孙子节点或右左孙子节点, 和AVL树的双旋转相同

**基于伸展树的区间操作**
- 区间提取 : 给定数列 $\{n_i\}_m$, 提取区间 $[n_a,n_b]$ 的子序列
  - 将 $n_a$ 旋转到根节点
  - 将 $n_b$ 旋转到根节点的右子节点
  - 提取树根右子树的左子树即为所求子序列
- 区间删除 : 删除区间 $[n_a,n_b]$ 的子序列
  - 同区间提取
  - 删除树根右子树的左子树
- 区间插入 : 插入区间 $[n_a,n_b]$ 的子序列
  - 将 $n_a$ 旋转到根节点
  - 将 $n_{a+1}$ 旋转到根节点的右子节点
  - 将待插入子序列构建成伸展树, 插入成为树根右子树的左子树
- 区间翻转 : 翻转区间 $[n_a,n_b]$ 的子序列
  - 同区间提取
  - 对树根右子树的左子树进行翻转 (交换每个节点的左右儿子)

**半伸展树(Semi-Splay)** : 每次伸展只对祖父节点进行一次旋转, 父节点取代祖父节点成为新的子树根, 然后当前节点由 $x$ 变为 $x$ 的父节点 (此时的子树根)
  - 半伸展不需要把 $x$ 旋转到根节点, 如 $x$ 的原层数是 $d$, 则伸展后的层数是 $d/2$
  - 如果记录信息存储在外部结点, 内部结点只作为索引结构, 则检索到某个外部结点时, 其内部父结点设为当前结点

**后缀树(Suffix Trie)** : 类似前缀树, 但每个从根到叶子的路径都对应字符串的一个后缀, 用于字符串匹配, 模式匹配, 模式搜索等. 
  - 为区分后缀子串, 在每个叶子节点后添加一个特殊字符$
  - 很容易查找 $P$ 是否是 $T$ 的子串 (依次检索)
  - 查找 $P$ 出现次数 : 沿着 $P$ 的路径走到叶子节点, 计算出现次数 $k$, 复杂度 $O(|P|+k)$
  - 找到T中最长重复子串 : 找到最深的分叉节点, 从根到该节点的路径即为最长重复子串 (子串可能相交)

> 后缀树似乎不考

### 几种平衡机制的比较
- **AVL树** : 完全平衡, 与访问频率无关, 只与插入, 删除顺序有关
- **伸展树** : 与操作频率相关, 根据插入、删除、检索等动态调整
- **红黑树** : 局部平衡, 统计性能好于 AVL树, 增删记录算法性能好

> **单旋** : AVL树插入-LL,RR型旋转, 伸展树splay-第一层节点, 红黑树插入-叔节点为黑-LL,RR型
> **两次同向单旋** : 伸展树splay-一字型旋转
> **双旋(两次异向单旋)** : AVL树插入-LR,RL型旋转, 伸展树splay-之字型旋转, 红黑树插入-叔节点为黑-LR,RL型
>
> 无论是哪种二叉树结构, LR型和RL型旋转后都是**孙子节点**成为新子树根
> 而LL 型和 RR型就未必了, 除了伸展树的splay是**孙子取代祖父**, 其他都是**父亲取代祖父**